"""
Яндекс выпускает на улицы тысячи беспилотных автомобилей, и теперь появляется отличная возможность 
оптимизации трафика на дорогах. Прежде всего требуется точно оценить время прибытия машины в место назначения.

На дороге автомобиль постоянно встречает светофоры, которые горят либо зелёным, либо красным. 
Время горения зелёного и красного света задаётся в секундах. Цикл переключения цветов повторяется 
бесконечно и начинается с красного цвета.

Так как скорость автомобиля известна, положения светофоров на дороге определяются временем, которое требуется, 
чтобы доехать до этого светофора из начала дороги при условии, что все предыдущие светофоры горят зелёным.

Каждый светофор также характеризуется временем горения красного и зелёного цвета.

Задача -- определить, за какое время автомобиль доберётся до конца дороги.

Например, имеется дорога длиной 10 единиц времени. Первый светофор расположен на отметке 3 единицы времени и 
характеризуется циклом 5 красный 5 зелёный. Второй светофор расположен на отметке 5, и время показа красного и 
зелёного для него 2 и 2.

Автомобиль стартует, через 3 единицы добирается до первого светофора, на котором горит красный. Он горит 5 единиц, 
то есть движение начинается с 5-го момента.

Через две единицы автомобиль добирается до второго светофора -- это абсолютный момент 7. В этот момент на светофоре 
горит зелёный, и автомобиль проезжает его без остановки. От второго светофора до конца дороги остаётся ещё 5 моментов, 
образом суммарное время автомобиля в пути равно 12 (7 + 5).

Функция

int Unmanned(int L, int N, int [][3] track)
получает на вход длину L дороги, количество светофоров на ней N, и описание самой дороги, где каждый элемент 
состоит из трёх значений: момент времени относительно начала дороги (когда в него прибудет автомобиль по свободной дороге), 
время показа красного света и время показа зелёного цвета.
Для примера выше параметры функции Unmanned() будут такими: 10, 2, [ [3,5,5], [5,2,2] ]

Функция возвращает реальное время, требуемое для преодоления дороги.
"""

def Unmanned(L, N, track):
    time = 0
    if track[0][0] >= L:
        return L
    else:
        for i in range(N):
            if i == 0:
                time = time + track[i][0]
                if time < track[i][1]:
                    time += track[i][1] - track[i][0]
                else:
                    cycle_iter = 0
                    count = 0
                    while cycle_iter < track[i][0]:
                        if count % 2 == 0:
                            cycle_iter += track[i][1]
                            count += 1
                        else:
                            cycle_iter += track[i][2]
                            count += 1
                    if count % 2 == 0:
                        time += (track[i][1] - track[i][0]%track[i][1])
                    elif (count % 2 == 1) and (track[i][0]%2 != 0):
                        time += (track[i][2] - track[i][0]%track[i][2])
                    if N == 1:
                        time += L-track[i][0]
                        return time

            else:
                if track[i][0] >= L:
                    return L-track[i-1][0] + time
                time = time + (track[i][0] - track[i-1][0])
                cycle_iter = 0
                count = 0
                while cycle_iter < track[i][0]:
                    if count % 2 == 0:
                        cycle_iter += track[i][1]
                        count += 1
                    else:
                        cycle_iter += track[i][2]
                        count += 1
                if count % 2 == 0:
                    time += (track[i][1] - track[i][0]%track[i][1])
                #elif (count % 2 == 1) and (track[i][0]%2 != 0):
                    #time += (track[i][2] - track[i][0]%track[i][2])
        time += L - track[-1][0]
        return time

    